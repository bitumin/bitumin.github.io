<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="¿Qué es el control de versiones?">

  <title>Introducción al control de versiones con Git: comandos básicos en entorno local</title>

  <link href="/assets/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://mitxelmoriana.com/programming/2016/01/20/introduccion-al-control-de-versiones-con-git-comandos-basicos-en-entorno-local.html">
  <link rel="alternate" type="application/rss+xml" title="MitxelMoriana" href="http://mitxelmoriana.com/feed.xml">
  <link rel="icon" type="image/png" href="/favicon.png">
</head>


  <body>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-71923540-1', 'auto');
    ga('send', 'pageview');

</script>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">MitxelMoriana</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post with-header-image" itemscope itemtype="http://schema.org/BlogPosting">

  
  <headerimagewrapper>
    <headerimage style="background-image: url('/headers/git.png');"></headerimage>
  </headerimagewrapper>
  

  <header class="post-header wrapper">
    <h1 class="post-title" itemprop="name headline">Introducción al control de versiones con Git: comandos básicos en entorno local</h1>
    <p class="post-meta"><time datetime="2016-01-20T00:00:00+01:00" itemprop="datePublished">Jan 20, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="qu-es-el-control-de-versiones">¿Qué es el control de versiones?</h1>

<p>¿Alguna vez te has fijado que los sistemas operativos (SO) van evolucionando con el tiempo? Por ejemplo: en Windows hemos tenido en los últimos años el Windows 7, el 8 y el 10. Con el SO Android o con Linux y sus distribuciones (Arch, Ubuntu, Debian, etc.) ocurre exactamente lo mismo. A veces las nuevas versiones suponen pequeñas mejoras y otras veces cambios radicales, casi siempre para mejor.</p>

<p>Si eres un gamer aficionado a los videojuegos te habrás dado cuenta que con los juegos ocurre algo parecido: periódicamente salen nuevos parches y updates de tus juegos favoritos. Con las app para móviles tres cuartos de lo mismo. En general, esto de ir sacando nuevas versiones ocurre con todo tipo de software.</p>

<p>Ocurre que, a menudo, en todo tipo de proyectos de desarrollo de software se acaban generando decenas, cientos, miles de ficheros de código y, de una versión a otra se han de modificar unos cuantos de ellos. Sería extremadamente laborioso llevar la cuenta, manualmente, de las líneas de código que se han modificado de una versión a otra. Si además trabajases en equipos de desarrolladores, imagínate lo complejo que sería coordinar los cambios realizados por dos o más programadores sobre los mismos ficheros. La implementación de nuevas versiones llevaría horas o incluso días de coordinación de cambios. Y por si no te has dado cuenta aún, te lo digo yo: en el mundillo de la programación de aplicaciones el ahorro de tiempo y el aumento de la productividad son más valiosos que el oro, la plata y que todo el mercado de stocks mundial y aún me quedo corto.</p>

<p>Por lo tanto tenemos una necesidad: poder automatizar y coordinar las versiones. Y de ahí nace lo que conocemos como el control de versiones y los sistemas de control de versiones (VCS), que básicamente son estrategias y software para realizar esa gestión de cambios.</p>

<h1 id="qu-es-eso-de-git">¿Qué es eso de Git?</h1>

<p>Git es un programa para control de versiones. No es el único ni necesariamente el mejor en todo. Hay docenas de sistemas de gestión de versiones por ahí, algunos son de pago, otros gratuitos, unos afrontan la problemática de editar los mismo fichero por distintas personas de una manera, otros de otra… No nos interesa demasiado entrar en detalle ni compararlos en este post, aunque si te pica la curiosidad siempre puedes echar un vistacillo por <a href="https://en.wikipedia.org/wiki/Comparison_of_version_control_software">aquí</a>.</p>

<p>Yo te voy a introducir a Git por la sencilla razón de que, junto con Mercurial, es el VCS más popular con diferencia (o eso me parece a mí). Además, sabiendo más o menos de qué va Git, la terminología del control de versiones y los conceptos generales (merge, branch, pull, push…), aprender a hacer lo mismo con un nuevo VCS es coser y cantar.</p>

<h1 id="git-bsico-bsico">Git básico, básico</h1>

<p>Como decía un compañero mío de universidad: “para aprender a andar primero hay que aprender a gatear”, y como para aprender a gatear primero hay que nacer, qué mejor que empezar por el principio de todo: la instalación de git.</p>

<h2 id="nacer-instalar-git-en-tu-ordenador">Nacer: instalar Git en tu ordenador</h2>

<p>Básicamente si usas Linux lo puedes instalar con tu gestor de paquetes habitual:</p>
<pre>sudo yum install git-all</pre>
<p>o</p>
<pre>sudo apt-get install git-all</pre>

<p>Si usas Mac te lo puedes bajar de <a href="http://git-scm.com/download/mac">aquí</a>. Si usas Windows te puedes bajar el instalador <a href="http://git-scm.com/download/win">aquí</a> y te será muy útil agregar la carpeta donde se te instale el ejecutable git al PATH de Windows para poder ejecutar git desde cualquier línea de comandos que abras.</p>

<p>Si necesitas más detalles sobre cómo instalarlo, problemas, casos especiales… ya sabes que Google es tu amigo. También puedes preguntar más abajo e intentaré ayudarte.</p>

<p>Si todo ha ido bien cuando escribas en tu terminal el comando <em>git version</em>, debería devolverte la versión del Git que has instalado en tu SO. Por ejemplo, en mi Ubuntu a mí me aparece:</p>
<pre>
$ git version
git version 2.5.0
</pre>
<p>Mientras que en la versión de Git para mi Windows me aparece</p>
<pre>
C:&#92;&#62; git version
git version 1.9.5
</pre>

<h2 id="aprendiendo-a-gatear-usar-git-en-tu-entorno-local">Aprendiendo a gatear: usar Git en tu entorno local</h2>

<p>La gracia de los sistemas de control de versiones (VCS) está, sobretodo, en la gestión de repositorios remotos, a los cuales puede acceder un equipo de desarrolladores (repositorios privados) o incluso cualquier persona que desee colaborar en el desarrollo de un proyecto de código abierto (repositorios públicos). Los repositorios son, sencillamente, los lugares donde se guarda el código de nuestro proyecto, se coordinan y se registran los cambios que se van haciendo (qué cambios se han hecho, quién los ha hecho, cuándo…).</p>

<p>Pero qué mejor manera de aprender a trabajar con repositorios remotos que aprendiendo primero a trabajar con las versiones de nuestro propio código en nuestro entorno local.</p>

<p>Por aquello de aprender practicando, vamos a crear un fichero de texto vacío en una nueva carpeta. El fichero de texto vacío representa un programa que iremos modificando para simular lo que serían modificaciones en la aplicación de verdad,</p>

<p>En mi Windows yo he creado una nueva carpeta en c:\myFakeProject\ y he creado dentro un nuevo fichero .txt vacío con el nombre thisIsAnAppYouBetterBelieveIt.txt . Nunca antes desarrollar aplicaciones fue tan rápido. Ahora abramos nuestra magnífica aplicación con apariencia de fichero de texto vacío con cualquier editor de texto (notepad, gedit o cualquier editor sencillo y rápido que tengas más a mano).</p>

<p>Escribamos alguna nueva línea de “código”, por ejemplo: “Hola mundo!”. Ahora borra la palabra “mundo” y sustitúyela por “Paco”. Guarda y cierra el fichero…</p>

<p>Muy bien, ahora vuelve a abrir el fichero (¿qué locura es ésta?) e intenta deshacer la última modificación (Ctrl+z), si tu editor no es más listo de lo habitual no deberías poder deshacer el último cambio realizado. Resulta que has perdido para siempre la palabra “mundo” (te has cargado el mundo, ¡estarás orgulloso de ti mismo!). Si no hubieses escrito esta modificación hace unos segundo seguramente no recordarías qué había allí escrito originalmente.</p>

<p>Imagínate que en vez de un .txt se trata de una aplicación de verdad y que, por error, modificaste la línea hace unas semanas. Te tocaría perder un tiempo precioso buscando la modificación que introdujiste sin querer.</p>

<p>Bien, vamos a poner solución a este problema con nuestro Git, nuestro flamante nuevo sistema de control de versiones. Comprueba que en tu terminal o línea de comandos estés en el directorio raíz de tu proyecto. En mi caso c:\myFakeProject\ y escribe</p>

<pre>git init</pre>

<p>Este comando creará una nueva carpeta oculta /.git en la raíz de tu proyecto, donde Git guarda toda la información necesaria del estado pasado y actual de tus versiones. De hecho, acabas de estrenar un sistema de control de versiones para tu nuevo proyecto. ¡Felicidades!</p>

<p>Siempre que queramos saber en qué estado se encuentra nuestro espacio de trabajo, debemos escribir:</p>

<pre>git status</pre>

<p>Hazlo. Te aparecerán cuatro o cinco líneas de información, entre las cuales se debería hacer referencia a los siguientes asuntos importantes (que en principio te sonarán a checo antiguo):</p>

<ul>
  <li>La rama o branch sobre la que estás trabajando, por ejemplo “On branch <strong>master</strong>”</li>
  <li>El commit o confirmación en cabeza (current HEAD commit). Por ejemplo: “Initial commit” (aún no has hecho ningún commit)</li>
  <li>Una lista de ficheros con cambios respecto al último commit (como no has hecho ningún cambio desde el git init, no debería aparecer nada de esto ahora).</li>
  <li>Una lista de ficheros que están untracked (ficheros que Git no está controlando). Estos suelen ser ficheros que acabas de crear, como el fichero .txt de nuestro ejemplo. Si te fijas, el nombre de tu .txt de ejemplo debería aparecerte en pantalla después de “Untracked files:”.</li>
</ul>

<p>Bien, vayamos por partes. ¿Qué es eso de la branch? Una branch o rama es una ramificación en el seguimiento de las versiones. Suponte que tú y otro desarrollador tenéis que trabajar sobre la misma aplicación y que no queréis tener que estar constantemente actualizando vuestra entorno de trabajo local con los cambios que realiza cada uno a diario sobre la misma rama. Una manera de trabajar en estos casos podría ser, por ejemplo, crear una rama nueva para cada desarrollador, que más tarde, al cabo de unos días, se fusionarán en una sola rama, es decir, se integrarán los dos cambios hechos por separado en una sola rama. A esto de fusionar ramas se le conoce como <strong>merging</strong>. Sobre branching y merging hablaremos en el próximo post, por ahora basta con que te suene.</p>

<p>¿Qué es eso del commit? Un commit o confirmación es la forma de decir con Git “confirmo los cambios que he hecho hasta ahora porque he terminado con este asunto y estoy seguro de que el asunto está resuelto”. Suponte que estás corrigiendo un error y modificas cinco ficheros de tu proyecto. Cuando acabas de modificarlo, testeas la aplicación y todo funciona: puedes dar por terminado el arreglo. Es muy buena idea, entonces, hacer un commit y ponerle un titulillo hermosamente explicativo como por ejemplo “fixed bug #6576”.</p>

<p>Podemos hacer lo mismo si acabamos de crear un proyecto o acabamos de crear nuevos ficheros dentro del proyecto. ¡De hecho, este es el caso en el que estamos ahora. Si intentas hacer un commit ahora, sin embargo, te aparecerá un mensajito preocupante, pruébalo:</p>

<pre>
git commit -m "My first commit"
...
nothing added to commit but untracked files present
</pre>

<p>Nada se ha añadido en nuestro commit. La razón es porque Git tiene un sistema de dos pasos para realizar el commit (stage + commit). Primero hemos de <em>stagear</em> los cambios realizados y luego realizar el commit. En el caso de un fichero recién creado podemos escribir:</p>

<pre>
git add thisIsAnAppYouBetterBelieveIt.txt
</pre>

<p>Como decía, a esto se le llama hacer staging de nuestros cambios (staging se puede traducir como “puesta en escena”). Pruébalo y haz un git status. Ahora deberías ver una diferencia importante respecto al principio. Ya no aparecen ficheros untracked en tus directorios de trabajo, en su lugar aparece una nueva línea tras “Changes to be committed”</p>

<pre>
new file:   thisIsAnAppYouBetterBelieveIt.txt
</pre>

<p>Lo que significa que nuestro fichero está listo para ser confirmado, es decir, para ser incluido en el próximo commit que hagamos. Vamos allá:</p>

<pre>
git commit -m "My first commit"
</pre>

<p>Una vez hecho esto volvamos a hacer un git status. Ahora git nos dirá que nuestro árbol de directorios de trabajo está libre de modificaciones desde el último commit (el que acabamos de hacer).</p>

<p>Bien, modifiquemos ahora nuestro querido fichero .txt. Ábrelo y cambia, por ejemplo, “Paco” por “Pedro”. Ahora guarda y sal de tu editor de texto. Volvamos a la línea de comandos. Haz un git status.</p>

<p>Ahora debería informarte git de que has modificado un fichero respecto al commit que tienes en cabeza (en nuestro caso, respeto al último commit que realizaste). ¿Recuerdas que la última vez que modificamos nuestro .txt no tuvimos forma de ver qué había cambiado respecto al texto original? Con git nunca jamás. Escribe:</p>

<pre>git diff</pre>

<p>Ahora debería aparecerte algo como esto</p>

<pre>
diff --git a/thisIsAnAppYouBetterBelieveIt.txt b/thisIsAnAppYouBetterBelieveIt.txt
index 5d8a8b4..4955b9f 100644
--- a/thisIsAnAppYouBetterBelieveIt.txt
+++ b/thisIsAnAppYouBetterBelieveIt.txt
@@ -1 +1 @@
-Hola Paco
\ No newline at end of file
+Hola Pedro
\ No newline at end of file
</pre>

<p>Para salir de esta pantalla de visualización de los cambios pulsa la tecla Q.</p>

<p>Precisamente git nos informa de los cambios que se han realizado, incluyendo las líneas del fichero donde se han realizado. En este caso los cambios que aún no han sido staged con respecto al commit en cabeza. Al igual que cuando creamos un fichero, cuando modificamos uno existente debemos hacer un staging de los cambios, por tanto, debemos volver a escribir:</p>

<pre>
git add thisIsAnAppYouBetterBelieveIt.txt
</pre>

<p>Y a continuación</p>
<pre>
git commit -m "I changed the name for the lulz"
</pre>

<p>Ahora quizá estés pensando… Joder, Mitxel… ¿Y si creo 200 ficheros, elimino 100 y modifico 500? ¿Tengo que hacer el staging uno a uno? Y la respuecta es que obviamente no. Aquí te dejo unos comandos muy útiles que te servirán para hacer el staging de cambios de múltiples ficheros al mismo tiempo:</p>

<pre>
git add -u    # Staging de todos los ficheros modificados o eliminados (sin los nuevos)
git add .     # Staging de todos los ficheros modificados o recién creados (sin los eliminados)
git add -A    # Staging de todos los ficheros modificados, eliminados o recién creados
</pre>

<p>Por supuesto, no te olvides de hacer el commit después de hacer el staging si estás contento con los cambios realizados. Por ahora puedes pensar en el staging como un paso previo en el que repasar los cambios realizados antes de realizar un commit o confirmación. De hecho, en un entorno profesional deberías tomarte bastante en serio lo de realizar un commit o, dicho de otro modo, nuca hagas un commit a lo loco, sin estar 100% seguro de que los cambios que has realizado son (prácticamente) los definitivos para resolver el asunto que te traes entre manos (implementar una nueva funcionalidad, corregir un bug…).</p>

<p>De todos modos no sufras demasiado si cometes un error al estilo “se me olvidó modificar este fichero”. Siempre puedes hacer nuevos commits corrigiendo errores o, aún mejor, enmendar el último commit realizado escribiendo:</p>

<pre>
git add fichero_que_se_me_olvidó_modificar
git commit --ammend
</pre>

<p>Esto sustituirá el último commit realizado por un commit idéntico pero que incluirá el fichero que olvidaste modificar/crear/eliminar.</p>

<p>En fin, espero que esta introducción te haya servido para empezar a moverte por el mundo de los VCS y, en particular, con Git. Aunque aún no hemos tratado el asunto de los branch y los repositorios piensa que ya estás capacitado para hacer un seguimiento de los cambios en tus proyectos en tu espacio de trabajo local. ¡Ya no tienes excusa para olvidar modificaciones realizadas en el pasado!</p>

<h1 id="consejillos">Consejillos</h1>

<p>Y ahora un par de consejos para facilitarte la vida:</p>

<ul>
<li>Siempre que comiences un nuevo proyecto, por pequeño y personal que sea, haz el seguimiento de cambios con tu VCS favorito. No subestimes la utilidad de saber los cambios realizados haces meses en un proyecto que tenías abandonado y que vuelves a retomar.</li> 
<li>En tus proyectos de desarrollo utiliza un IDE compatible con el VCS que utilices. Hay IDEs muy buenos que te permiten automatizar la ejecución de comandos git (como los que acabamos de aprender y otros cuantos) o ejecutarlos con un par de clicks. Mi IDE, por ejemplo, me pinta sobre mi árbol de directorios los nombres de los ficheros modificados de azul o los recién creados y no staged en rojo y los staged en verde. ¡Parece una tontería pero es la leche de útil!</li>
<li>Puedes utilizar alguna interfaz gráfica para git que, como mínimo, te ayudará a visualizar los cambios realizados en los distintos ficheros antes o después de hacer el staging o el commit. Hay montones y muy buenas GUI: GitHub Desktop, SourceTree, git-cola... De nuevo, Google es tu amigo. Cuando aprendas a manejarte con los repositorios remotos les sacarás mucho partido.</li>
</ul>

<h1 id="prximamente">Próximamente…</h1>
<p>En el próximo post sobre Git hablaré de cómo manejar las branches y cómo intercambiar datos con los repositorios remotos: la auténtica belleza de todo este asuntillo.</p>

<p>Recuerda que puedes preguntarme sobre cualquier cosa que no te haya quedado clara, sobre errores que te van surgiendo o indicarme correcciones aquí abajo, en el área de comentarios.</p>


  </div>

</article>

        
<div id="disqus_thread"></div>
<script>
     var disqus_config = function () {
         this.page.url = 'http://mitxelmoriana.com/programming/2016/01/20/introduccion-al-control-de-versiones-con-git-comandos-basicos-en-entorno-local.html';
     };
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//mitxelmoriana.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">MitxelMoriana</h2>

    <div class="footer-col-wrapper">

      <div class="footer-col footer-col-alt-1">

        <a href="mailto:moriana.mitxel@gmail.com"><span class="email-link"><i class="fa fa-envelope"></i> moriana.mitxel@gmail.com</span></a>

        <br>
        <ul class="social-media-list">

          
          <li>
            <a href="https://github.com/bitumin"><i class="fa fa-github-square"></i></a>

          </li>
          

          
          <li>
            <a href="https://facebook.com/mitxel.moriana"><i class="fa fa-facebook-official"></i></a>
          </li>
          

          
          <li>
            <a href="https://linkedin.com/in/morianamitxel"><i class="fa fa-linkedin-square"></i></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/mitxelmoriana"><i class="fa fa-twitter-square"></i></a>

          </li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-alt-2">
        <p>Hi there. I'm Mitxel Moriana, freelance developer, technophile, entrepeneur and blogger. This is the blog I use to talk mostly about my work, so you can expect to find many techy and programming related posts that I hope you'll find useful!
</p>
      </div>

    </div>
  </div>
</footer>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="/assets/bootstrap.min.js"></script>


  </body>

</html>
